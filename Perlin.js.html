<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Perlin.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="nav">
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="FBM.html">FBM</a><ul class='methods'><li data-type='method'><a href="FBM.html#get">get</a></li></ul></li><li><a href="Perlin.html">Perlin</a><ul class='methods'><li data-type='method'><a href="Perlin.html#.map">map</a></li><li data-type='method'><a href="Perlin.html#get2">get2</a></li><li data-type='method'><a href="Perlin.html#get3">get3</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Perlin.js</h1>
    

    <!--container.tmpl-->




    <!--source.tmpl-->

    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as THREE from "three";
import header from "./shaders/header.js";
import p from "./p.js";

/**
 * An implimentation of Perlin Noise by Ken Perlin.
 */
export class Perlin {
  /**
   * GLSL Shader Chunk for 2D Perlin Noise. Can be used with
   * three-CustomShaderMaterial.
   * See: &lt;a href="https://github.com/FarazzShaikh/THREE-CustomShaderMaterial">three-CustomShaderMaterial&lt;/a>
   */
  shaderChunk;

  /**
   *
   * @param {number} seed Seed Value for PRNG.
   */
  constructor(seed) {
    const _gradientVecs = [
      // 2D Vecs
      new THREE.Vector3(1, 1, 0),
      new THREE.Vector3(-1, 1, 0),
      new THREE.Vector3(1, -1, 0),
      new THREE.Vector3(-1, -1, 0),
      // + 3D Vecs
      new THREE.Vector3(1, 0, 1),
      new THREE.Vector3(-1, 0, 1),
      new THREE.Vector3(1, 0, -1),
      new THREE.Vector3(-1, 0, -1),
      new THREE.Vector3(0, 1, 1),
      new THREE.Vector3(0, -1, 1),
      new THREE.Vector3(0, 1, -1),
      new THREE.Vector3(0, -1, -1),
    ];

    var perm = new Array(512);
    var gradP = new Array(512);

    if (!seed) seed = 1;
    seed *= 65536;

    seed = Math.floor(seed);
    if (seed &lt; 256) {
      seed |= seed &lt;&lt; 8;
    }

    for (var i = 0; i &lt; 256; i++) {
      var v;
      if (i &amp; 1) {
        v = p[i] ^ (seed &amp; 255);
      } else {
        v = p[i] ^ ((seed >> 8) &amp; 255);
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = _gradientVecs[v % 12];
    }

    this._seed = seed;

    this._offsetMatrix = [
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 0, 1),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, 1, 1),
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(1, 0, 1),
      new THREE.Vector3(1, 1, 0),
      new THREE.Vector3(1, 1, 1),
    ];

    this.shaderChunk = {
      defines: "",
      header: header,
      main: "",
      uniforms: [{ three_noise_seed: this._seed }],
    };

    this.perm = perm;
    this.gradP = gradP;
  }

  _fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  _lerp(a, b, t) {
    return (1 - t) * a + t * b;
  }

  _gradient(posInCell) {
    if (posInCell instanceof THREE.Vector3) {
      return posInCell.x + this.perm[posInCell.y + this.perm[posInCell.z]];
    } else {
      return posInCell.x + this.perm[posInCell.y];
    }
  }

  /**
   * Maps a number from one range to another.
   * @param {number} x       Input Number
   * @param {number} in_min  Current range minimum
   * @param {number} in_max  Current range maximum
   * @param {number} out_min New range minimum
   * @param {number} out_max New range maximum
   * @returns {number} Input Mapped to range [out_min, out_max]
   */
  static map(x, in_min, in_max, out_min, out_max) {
    return ((x - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;
  }

  /**
   * Samples 2D Perlin Nosie at given coordinates.
   * @param {THREE.Vector2 | THREE.Vector3} input Coordincates to sample at
   * @returns {number} Value of Perlin Noise at that coordinate.
   */
  get2(input) {
    if (input.z !== undefined) input = new THREE.Vector2(input.x, input.y);

    const cell = new THREE.Vector2(Math.floor(input.x), Math.floor(input.y));
    input.sub(cell);

    cell.x &amp;= 255;
    cell.y &amp;= 255;

    const gradiantDot = [];
    for (let i = 0; i &lt; 4; i++) {
      const s3 = this._offsetMatrix[i * 2];
      const s = new THREE.Vector2(s3.x, s3.y);

      const grad3 = this.gradP[
        this._gradient(new THREE.Vector2().addVectors(cell, s))
      ];
      const grad2 = new THREE.Vector2(grad3.x, grad3.y);
      const dist2 = new THREE.Vector2().subVectors(input, s);

      gradiantDot.push(grad2.dot(dist2));
    }

    const u = this._fade(input.x);
    const v = this._fade(input.y);

    const value = this._lerp(
      this._lerp(gradiantDot[0], gradiantDot[2], u),
      this._lerp(gradiantDot[1], gradiantDot[3], u),
      v
    );

    return Perlin.map(value, -1, 1, 0, 1);
  }

  /**
   * Samples 3D Perlin Nosie at given coordinates.
   * @param {THREE.Vector}3 input Coordincates to sample at
   * @returns {number} Value of Perlin Noise at that coordinate.
   */
  get3(input) {
    if (input.z === undefined)
      throw "Input to Perlin::get3() must be of type THREE.Vector3";

    const cell = new THREE.Vector3(
      Math.floor(input.x),
      Math.floor(input.y),
      Math.floor(input.z)
    );
    input.sub(cell);

    cell.x &amp;= 255;
    cell.y &amp;= 255;
    cell.z &amp;= 255;

    const gradiantDot = [];
    for (let i = 0; i &lt; 8; i++) {
      const s = this._offsetMatrix[i];

      const grad3 = this.gradP[
        this._gradient(new THREE.Vector3().addVectors(cell, s))
      ];
      const dist2 = new THREE.Vector3().subVectors(input, s);

      gradiantDot.push(grad3.dot(dist2));
    }

    const u = this._fade(input.x);
    const v = this._fade(input.y);
    const w = this._fade(input.z);

    const value = this._lerp(
      this._lerp(
        this._lerp(gradiantDot[0], gradiantDot[4], u),
        this._lerp(gradiantDot[1], gradiantDot[5], u),
        w
      ),
      this._lerp(
        this._lerp(gradiantDot[2], gradiantDot[6], u),
        this._lerp(gradiantDot[3], gradiantDot[7], u),
        w
      ),
      v
    );

    return Perlin.map(value, -1, 1, 0, 1);
  }
}
</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Wed May 05 2021 11:20:19 GMT+0000 (Coordinated Universal Time) using the LOKE theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
